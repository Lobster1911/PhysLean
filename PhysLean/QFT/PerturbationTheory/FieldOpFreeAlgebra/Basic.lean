/-
Copyright (c) 2025 Joseph Tooby-Smith. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Joseph Tooby-Smith
-/
import PhysLean.QFT.PerturbationTheory.FieldSpecification.CrAnFieldOp
import PhysLean.QFT.PerturbationTheory.FieldSpecification.CrAnSection
/-!

# Creation and annihilation free-algebra

This module defines the creation and annihilation algebra for a field structure.

The creation and annihilation algebra extends from the state algebra by adding information about
whether a state is a creation or annihilation operator.

The algebra is spanned by lists of creation/annihilation states.

The main structures defined in this module are:

* `FieldOpFreeAlgebra` - The creation and annihilation algebra
* `ofCrAnOpF` - Maps a creation/annihilation state to the algebra
* `ofCrAnListF` - Maps a list of creation/annihilation states to the algebra
* `ofFieldOpF` - Maps a state to a sum of creation and annihilation operators
* `crPartF` - The creation part of a state in the algebra
* `anPartF` - The annihilation part of a state in the algebra
* `superCommuteF` - The super commutator on the algebra

The key lemmas show how these operators interact, particularly focusing on the
super commutation relations between creation and annihilation operators.

-/

namespace FieldSpecification
variable {ğ“• : FieldSpecification}
variable {Î¹in Î¹x Î¹out : Type}

/-- For a field specification `ğ“•`, the algebra `ğ“•.FieldOpFreeAlgebra` is
  the free algebra generated by `ğ“•.CrAnFieldOp`. -/
abbrev FieldOpFreeAlgebra (ğ“• : FieldSpecification) (Î¹in Î¹x Î¹out : Type) : Type :=
  FreeAlgebra â„‚ (ğ“•.CrAnFieldOp Î¹in Î¹x Î¹out)

namespace FieldOpFreeAlgebra

remark naming_convention := "
  For mathematical objects defined in relation to `FieldOpFreeAlgebra` the postfix `F`
  may be given to
  their names to indicate that they are related to the free algebra.
  This is to avoid confusion when working within the context of `FieldOpAlgebra` which is defined
  as a quotient of `FieldOpFreeAlgebra`."

/-- For a field specification `ğ“•`, and a element `Ï†` of `ğ“•.CrAnFieldOp`,
  `ofCrAnOpF Ï†` is defined as the element of `ğ“•.FieldOpFreeAlgebra` formed by `Ï†`. -/
def ofCrAnOpF (Ï† : ğ“•.CrAnFieldOp Î¹in Î¹x Î¹out) : ğ“•.FieldOpFreeAlgebra Î¹in Î¹x Î¹out :=
  FreeAlgebra.Î¹ â„‚ Ï†

/--
The algebra `ğ“•.FieldOpFreeAlgebra` satisfies the universal property that for any other algebra
  `A` (e.g. the operator algebra of the theory) with a map `f : ğ“•.CrAnFieldOp â†’ A` (e.g.
  the inclusion of the creation and annihilation parts of field operators into the
  operator algebra) there is a unique algebra map `g : ğ“•.FieldOpFreeAlgebra â†’ A`
  such that `g âˆ˜ ofCrAnOpF = f`.

  The unique `g` is given by `FreeAlgebra.lift â„‚ f`.
-/
lemma universality {A : Type} [Semiring A] [Algebra â„‚ A] (f : ğ“•.CrAnFieldOp Î¹in Î¹x Î¹out â†’ A) :
    âˆƒ! g : ğ“•.FieldOpFreeAlgebra Î¹in Î¹x Î¹out â†’â‚[â„‚] A, g âˆ˜ ofCrAnOpF = f := by
  use FreeAlgebra.lift â„‚ f
  apply And.intro
  Â· funext x
    simp [ofCrAnOpF]
  Â· intro g hg
    ext x
    simpa using congrFun hg x

/-- For a field specification `ğ“•`, and a list `Ï†s` of `ğ“•.CrAnFieldOp`,
  `ofCrAnListF Ï†s` is defined as the element of `ğ“•.FieldOpFreeAlgebra`
  obtained by the product of `ofCrAnListF Ï†` for each `Ï†` in `Ï†s`.
  For example `ofCrAnListF [Ï†â‚, Ï†â‚‚, Ï†â‚ƒ] = ofCrAnOpF Ï†â‚ * ofCrAnOpF Ï†â‚‚ * ofCrAnOpF Ï†â‚ƒ`.
  The set of all `ofCrAnListF Ï†s` forms a basis of `FieldOpFreeAlgebra ğ“•`. -/
def ofCrAnListF (Ï†s : List (ğ“•.CrAnFieldOp Î¹in Î¹x Î¹out)) : ğ“•.FieldOpFreeAlgebra Î¹in Î¹x Î¹out :=
  (List.map ofCrAnOpF Ï†s).prod

@[simp]
lemma ofCrAnListF_nil : ofCrAnListF ([] : List (ğ“•.CrAnFieldOp Î¹in Î¹x Î¹out)) = 1 := rfl

lemma ofCrAnListF_cons (Ï† : ğ“•.CrAnFieldOp Î¹in Î¹x Î¹out) (Ï†s : List (ğ“•.CrAnFieldOp Î¹in Î¹x Î¹out)) :
    ofCrAnListF (Ï† :: Ï†s) = ofCrAnOpF Ï† * ofCrAnListF Ï†s := rfl

lemma ofCrAnListF_append (Ï†s Ï†s' : List (ğ“•.CrAnFieldOp Î¹in Î¹x Î¹out)) :
    ofCrAnListF (Ï†s ++ Ï†s') = ofCrAnListF Ï†s * ofCrAnListF Ï†s' := by
  simp [ofCrAnListF, List.map_append]

lemma ofCrAnListF_singleton (Ï† : ğ“•.CrAnFieldOp Î¹in Î¹x Î¹out) :
    ofCrAnListF [Ï†] = ofCrAnOpF Ï† := by simp [ofCrAnListF]

/-- For a field specification `ğ“•`, and an element `Ï†` of `ğ“•.FieldOp`,
  `ofFieldOpF Ï†` is the element of `ğ“•.FieldOpFreeAlgebra` formed by summing over
  `ofCrAnOpF` of the
  creation and annihilation parts of `Ï†`.

  For example, for `Ï†` an incoming asymptotic field operator we get
  `ofCrAnOpF âŸ¨Ï†, ()âŸ©`, and for `Ï†` a
  position field operator we get `ofCrAnOpF âŸ¨Ï†, .createâŸ© + ofCrAnOpF âŸ¨Ï†, .annihilateâŸ©`. -/
def ofFieldOpF (Ï† : ğ“•.FieldOp Î¹in Î¹x Î¹out) : ğ“•.FieldOpFreeAlgebra Î¹in Î¹x Î¹out :=
  âˆ‘ (i : ğ“•.fieldOpToCrAnType Ï†), ofCrAnOpF âŸ¨Ï†, iâŸ©

/-- For a field specification `ğ“•`, and a list `Ï†s` of `ğ“•.FieldOp`,
  `ğ“•.ofFieldOpListF Ï†s` is defined as the element of `ğ“•.FieldOpFreeAlgebra`
  obtained by the product of `ofFieldOpF Ï†` for each `Ï†` in `Ï†s`.
  For example `ofFieldOpListF [Ï†â‚, Ï†â‚‚, Ï†â‚ƒ] = ofFieldOpF Ï†â‚ * ofFieldOpF Ï†â‚‚ * ofFieldOpF Ï†â‚ƒ`. -/
def ofFieldOpListF (Ï†s : List (ğ“•.FieldOp Î¹in Î¹x Î¹out)) : ğ“•.FieldOpFreeAlgebra Î¹in Î¹x Î¹out :=
  (List.map ofFieldOpF Ï†s).prod

remark notation_drop := "In doc-strings explicit applications of `ofCrAnOpF`,
`ofCrAnListF`, `ofFieldOpF`, and `ofFieldOpListF` will often be dropped."

/-- Coercion from `List ğ“•.FieldOp` to `FieldOpFreeAlgebra ğ“•` through `ofFieldOpListF`. -/
instance : Coe (List (ğ“•.FieldOp Î¹in Î¹x Î¹out)) (ğ“•.FieldOpFreeAlgebra Î¹in Î¹x Î¹out) :=
  âŸ¨ofFieldOpListFâŸ©

@[simp]
lemma ofFieldOpListF_nil : ofFieldOpListF ([] : List (ğ“•.FieldOp Î¹in Î¹x Î¹out)) = 1 := rfl

lemma ofFieldOpListF_cons (Ï† : ğ“•.FieldOp Î¹in Î¹x Î¹out) (Ï†s : List (ğ“•.FieldOp Î¹in Î¹x Î¹out)) :
    ofFieldOpListF (Ï† :: Ï†s) = ofFieldOpF Ï† * ofFieldOpListF Ï†s := rfl

lemma ofFieldOpListF_singleton (Ï† : ğ“•.FieldOp Î¹in Î¹x Î¹out) :
    ofFieldOpListF [Ï†] = ofFieldOpF Ï† := by simp [ofFieldOpListF]

lemma ofFieldOpListF_append (Ï†s Ï†s' : List (ğ“•.FieldOp Î¹in Î¹x Î¹out)) :
    ofFieldOpListF (Ï†s ++ Ï†s') = ofFieldOpListF Ï†s * ofFieldOpListF Ï†s' := by
  dsimp only [ofFieldOpListF]
  rw [List.map_append, List.prod_append]

lemma ofFieldOpListF_sum (Ï†s : List (ğ“•.FieldOp Î¹in Î¹x Î¹out)) :
    ofFieldOpListF Ï†s = âˆ‘ (s : CrAnSection Ï†s), ofCrAnListF s.1 := by
  induction Ï†s with
  | nil => simp
  | cons Ï† Ï†s ih =>
    rw [CrAnSection.sum_cons]
    dsimp only [CrAnSection.cons, ofCrAnListF_cons]
    conv_rhs =>
      enter [2, x]
      rw [â† Finset.mul_sum]
    rw [â† Finset.sum_mul, ofFieldOpListF_cons, â† ih]
    rfl

/-!

## Creation and annihilation parts of a state

-/

/-- The algebra map taking an element of the free-state algebra to
  the part of it in the creation and annihilation free algebra
  spanned by creation operators. -/
def crPartF : ğ“•.FieldOp Î¹in Î¹x Î¹out â†’ ğ“•.FieldOpFreeAlgebra Î¹in Î¹x Î¹out := fun Ï† =>
  match Ï† with
  | FieldOp.inAsymp Ï† => ofCrAnOpF âŸ¨FieldOp.inAsymp Ï†, ()âŸ©
  | FieldOp.position Ï† => ofCrAnOpF âŸ¨FieldOp.position Ï†, CreateAnnihilate.createâŸ©
  | FieldOp.outAsymp _ => 0

@[simp]
lemma crPartF_negAsymp (Ï† : (Î£ f, ğ“•.AsymptoticLabel f) Ã— Î¹in) :
    crPartF (Î¹in := Î¹in) (Î¹x := Î¹x) (Î¹out := Î¹out) (FieldOp.inAsymp Ï†) =
    ofCrAnOpF âŸ¨FieldOp.inAsymp Ï†, ()âŸ© := by
  simp [crPartF]

@[simp]
lemma crPartF_position (Ï† : (Î£ f, ğ“•.PositionLabel f) Ã— Î¹x) :
    crPartF (Î¹in := Î¹in) (Î¹x := Î¹x) (Î¹out := Î¹out) (FieldOp.position Ï†) =
    ofCrAnOpF âŸ¨FieldOp.position Ï†, CreateAnnihilate.createâŸ© := by
  simp [crPartF]

@[simp]
lemma crPartF_posAsymp (Ï† : (Î£ f, ğ“•.AsymptoticLabel f) Ã— Î¹out) :
    crPartF (Î¹in := Î¹in) (Î¹x := Î¹x) (Î¹out := Î¹out) (FieldOp.outAsymp Ï†) = 0 := by
  simp [crPartF]

/-- The algebra map taking an element of the free-state algebra to
  the part of it in the creation and annihilation free algebra
  spanned by annihilation operators. -/
def anPartF : ğ“•.FieldOp Î¹in Î¹x Î¹out â†’ ğ“•.FieldOpFreeAlgebra Î¹in Î¹x Î¹out := fun Ï† =>
  match Ï† with
  | FieldOp.inAsymp _ => 0
  | FieldOp.position Ï† => ofCrAnOpF âŸ¨FieldOp.position Ï†, CreateAnnihilate.annihilateâŸ©
  | FieldOp.outAsymp Ï† => ofCrAnOpF âŸ¨FieldOp.outAsymp Ï†, ()âŸ©

@[simp]
lemma anPartF_negAsymp (Ï† : (Î£ f, ğ“•.AsymptoticLabel f) Ã— Î¹in) :
    anPartF (Î¹in := Î¹in) (Î¹x := Î¹x) (Î¹out := Î¹out) (FieldOp.inAsymp Ï†) = 0 := by
  simp [anPartF]

@[simp]
lemma anPartF_position (Ï† : (Î£ f, ğ“•.PositionLabel f) Ã— Î¹x) :
    anPartF (Î¹in := Î¹in) (Î¹x := Î¹x) (Î¹out := Î¹out) (FieldOp.position Ï†) =
    ofCrAnOpF âŸ¨FieldOp.position Ï†, CreateAnnihilate.annihilateâŸ© := by
  simp [anPartF]

@[simp]
lemma anPartF_posAsymp (Ï† : (Î£ f, ğ“•.AsymptoticLabel f) Ã— Î¹out) :
    anPartF (Î¹in := Î¹in) (Î¹x := Î¹x) (Î¹out := Î¹out) (FieldOp.outAsymp Ï†) =
    ofCrAnOpF âŸ¨FieldOp.outAsymp Ï†, ()âŸ© := by
  simp [anPartF]

lemma ofFieldOpF_eq_crPartF_add_anPartF (Ï† : ğ“•.FieldOp Î¹in Î¹x Î¹out) :
    ofFieldOpF Ï† = crPartF Ï† + anPartF Ï† := by
  rw [ofFieldOpF]
  cases Ï† with
  | inAsymp Ï† => simp [fieldOpToCrAnType]
  | position Ï† => simp [fieldOpToCrAnType, CreateAnnihilate.sum_eq]
  | outAsymp Ï† => simp [fieldOpToCrAnType]

/-!

## The basis of the creation and annihilation free-algebra.

-/

/-- The basis of the free creation and annihilation algebra formed by lists of CrAnFieldOp. -/
noncomputable def ofCrAnListFBasis :
    Basis (List (ğ“•.CrAnFieldOp Î¹in Î¹x Î¹out)) â„‚ (ğ“•.FieldOpFreeAlgebra Î¹in Î¹x Î¹out) where
  repr := FreeAlgebra.equivMonoidAlgebraFreeMonoid.toLinearEquiv

@[simp]
lemma ofListBasis_eq_ofList (Ï†s : List (ğ“•.CrAnFieldOp Î¹in Î¹x Î¹out)) :
    ofCrAnListFBasis Ï†s = ofCrAnListF Ï†s := by
  simp only [ofCrAnListFBasis, FreeAlgebra.equivMonoidAlgebraFreeMonoid, MonoidAlgebra.of_apply,
    Basis.coe_ofRepr, AlgEquiv.toLinearEquiv_symm, AlgEquiv.toLinearEquiv_apply,
    AlgEquiv.ofAlgHom_symm_apply, ofCrAnListF]
  erw [MonoidAlgebra.lift_apply]
  simp only [zero_smul, Finsupp.sum_single_index, one_smul]
  rw [@FreeMonoid.lift_apply]
  match Ï†s with
  | [] => rfl
  | Ï† :: Ï†s => erw [List.map_cons]

/-!

## Some useful multi-linear maps.

-/

/-- The bi-linear map associated with multiplication in `FieldOpFreeAlgebra`. -/
noncomputable def mulLinearMap : ğ“•.FieldOpFreeAlgebra Î¹in Î¹x Î¹out â†’â‚—[â„‚]
    ğ“•.FieldOpFreeAlgebra Î¹in Î¹x Î¹out â†’â‚—[â„‚]
    ğ“•.FieldOpFreeAlgebra Î¹in Î¹x Î¹out where
  toFun a := {
    toFun := fun b => a * b,
    map_add' := fun c d => by simp [mul_add]
    map_smul' := by simp}
  map_add' := fun a b => by
    ext c
    simp [add_mul]
  map_smul' := by
    intros
    ext c
    simp [smul_mul']

lemma mulLinearMap_apply (a b : ğ“•.FieldOpFreeAlgebra Î¹in Î¹x Î¹out) :
    mulLinearMap a b = a * b := rfl

/-- The linear map associated with scalar-multiplication in `FieldOpFreeAlgebra`. -/
noncomputable def smulLinearMap (c : â„‚) : ğ“•.FieldOpFreeAlgebra Î¹in Î¹x Î¹out â†’â‚—[â„‚]
    ğ“•.FieldOpFreeAlgebra Î¹in Î¹x Î¹out where
  toFun a := c â€¢ a
  map_add' := by simp
  map_smul' m x := by simp [smul_smul, RingHom.id_apply, NonUnitalNormedCommRing.mul_comm]

end FieldOpFreeAlgebra

end FieldSpecification
